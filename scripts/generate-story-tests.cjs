#!/usr/bin/env node

/**
 * Generate Ladle Story Tests
 *
 * This script fetches all stories from Ladle's meta.json and generates
 * individual Playwright test files - one test per story.
 *
 * Usage:
 *   node scripts/generate-story-tests.cjs
 *
 * Or add to package.json:
 *   "test:stories:generate": "node scripts/generate-story-tests.cjs"
 */

const http = require('http');
const fs = require('fs');
const path = require('path');

const LADLE_PORT = 6006;
const OUTPUT_DIR = path.join(__dirname, '..', 'tests', 'stories');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'all-stories.spec.ts');

/**
 * Fetches meta.json from Ladle server
 */
function fetchMetaJson() {
  return new Promise((resolve, reject) => {
    http
      .get(`http://localhost:${LADLE_PORT}/meta.json`, (res) => {
        let data = '';

        res.on('data', (chunk) => {
          data += chunk;
        });

        res.on('end', () => {
          try {
            resolve(JSON.parse(data));
          } catch (error) {
            reject(new Error(`Failed to parse meta.json: ${error.message}`));
          }
        });
      })
      .on('error', (error) => {
        reject(
          new Error(
            `Failed to fetch meta.json. Is Ladle running on port ${LADLE_PORT}? Error: ${error.message}`
          )
        );
      });
  });
}

/**
 * Generates test code for all stories
 */
function generateTestFile(stories) {
  const storyEntries = Object.entries(stories);

  const testContent = `/**
 * Auto-generated Ladle Story Validation Tests
 * 
 * Generated by: scripts/generate-story-tests.cjs
 * Generated at: ${new Date().toISOString()}
 * Total stories: ${storyEntries.length}
 *
 * DO NOT EDIT MANUALLY - Regenerate using:
 *   npm run test:stories:generate
 */

import { test, expect, Page } from '@playwright/test';
import type { ConsoleMessage } from '@playwright/test';

interface ValidationResult {
  consoleErrors: string[];
  pageErrors: string[];
}

/**
 * Validates a story by checking for errors and basic rendering
 */
async function validateStory(
  page: Page,
  storyKey: string,
  storyName: string
): Promise<ValidationResult> {
  const consoleErrors: string[] = [];
  const pageErrors: string[] = [];

  const consoleHandler = (msg: ConsoleMessage) => {
    if (msg.type() === 'error') {
      const text = msg.text();
      if (
        !text.includes('React does not recognize') &&
        !text.includes('Warning: ') &&
        !text.includes('DevTools') &&
        !text.includes('Download the React DevTools')
      ) {
        consoleErrors.push(text);
      }
    }
  };

  const errorHandler = (error: Error) => {
    pageErrors.push(error.message);
  };

  page.on('console', consoleHandler);
  page.on('pageerror', errorHandler);

  try {
    const url = \`/?story=\${storyKey}&mode=preview\`;
    const response = await page.goto(url, {
      waitUntil: 'networkidle',
      timeout: 30000,
    });

    expect(response?.status(), \`Story "\${storyName}" failed to load\`).toBe(200);
    await page.waitForTimeout(1000);

    const errorBoundary = await page.locator('[data-error-boundary]').count();
    expect(
      errorBoundary,
      \`Story "\${storyName}" triggered an error boundary\`
    ).toBe(0);

    return { consoleErrors, pageErrors };
  } finally {
    page.off('console', consoleHandler);
    page.off('pageerror', errorHandler);
  }
}

test.describe('Ladle Story Validation - All Stories', () => {
  test.describe.configure({ mode: 'parallel' });

${storyEntries
  .map(([storyKey, metadata]) => {
    const testName = [...metadata.levels, metadata.name].join(' / ');
    const safeName = testName.replace(/['"]/g, '\\"');

    return `  test('${safeName}', async ({ page }) => {
    const result = await validateStory(page, '${storyKey}', '${safeName}');

    expect(
      result.consoleErrors.length,
      \`Story produced \${result.consoleErrors.length} console error(s): \${result.consoleErrors.join('; ')}\`
    ).toBe(0);

    expect(
      result.pageErrors.length,
      \`Story threw \${result.pageErrors.length} uncaught exception(s): \${result.pageErrors.join('; ')}\`
    ).toBe(0);
  });
`;
  })
  .join('\n')}
});
`;

  return testContent;
}

/**
 * Main execution
 */
async function main() {
  console.log('üîç Fetching stories from Ladle...\n');

  try {
    const meta = await fetchMetaJson();
    const stories = meta.stories;
    const storyCount = Object.keys(stories).length;

    console.log(`üìö Found ${storyCount} stories\n`);

    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Generate test file
    const testContent = generateTestFile(stories);
    fs.writeFileSync(OUTPUT_FILE, testContent, 'utf8');

    console.log(`‚úÖ Generated test file: ${OUTPUT_FILE}`);
    console.log(`   - ${storyCount} individual tests created`);
    console.log(`\nRun tests with:`);
    console.log(`   npx playwright test ${OUTPUT_FILE} --config=playwright.refinement.config.ts\n`);
  } catch (error) {
    console.error(`‚ùå Error: ${error.message}\n`);
    console.error('Make sure Ladle is running:');
    console.error('   npm run catalog:dev\n');
    process.exit(1);
  }
}

main();
